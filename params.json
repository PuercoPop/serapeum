{"name":"Serapeum","tagline":"Utilities beyond Alexandria","body":"# Overview\r\n\r\nSerapeum is a conservative library of Common Lisp utilities. It is a\r\nsupplement, not a competitor, to Alexandria. That means it is safe to\r\ndo:\r\n\r\n    (defpackage ... (:use #:cl #:alexandria #:serapeum),\r\n\r\nwithout package conflicts.\r\n\r\nThere may already be too many utility libraries for Common Lisp.\r\nReleasing another has become something to apologize for, not\r\ncelebrate. But I would rather make my apologies than have to maintain\r\ncopy-pasted versions of the same utilities across a dozen systems.\r\nAnd, though Serapeum is justified even if only I ever use it, the best\r\nway to ensure its quality is to write it as if for general use.\r\n\r\nSerapeum is conservative: it contains only utilities I actually use,\r\nand which have survived refactoring. But it is less conservative than\r\nAlexandria. Alexandria limits itself to utilities with a Common Lisp\r\npedigree. Serapeum casts a wider net: other dialects of Lisp, and\r\nother languages in the functional and array families, have been\r\ndrafted.\r\n\r\nAlexandria is self-contained. It exists in splendid isolation, without\r\ndepending on, or even acknowledging, other libraries. Serapeum tries\r\nto be a good citizen of the Quicklisp era: whenever possible, it\r\navoids duplicating functionality that can be had elsewhere.\r\n\r\nSome of the utilities in Serapeum are original; others are borrowed\r\nfrom other languages, or from other Lispers. I try to give credit in\r\nthe docstrings, but sometimes I have forgotten where I got an idea or\r\na name. I regard missing credits as bugs: please report them.\r\n\r\nSerapeum is intended to be portable, but it is only tested where it is\r\ndeveloped, on SBCL and Clozure CL. Patches for other Lisps are\r\nwelcome, whether bug fixes or unportable enhancements.\r\n\r\n# Commentary\r\n\r\nOne goal of Serapeum is to have excellent documentation. A utility\r\nlibrary is a fork of its language; it deserves documentation of the\r\nsame quality as a language reference. If a utility is not worth\r\ndocumenting, it is not worth having.\r\n\r\nThe full function reference will be found [here](reference.md). (It is\r\nin a separate file in deference to documentation browsers, which often\r\nprint the README as a preamble to their own function reference).\r\n\r\nMost utilities in Serapeum stand alone, but there are two families of\r\nnote: the `fbind` macros, and the sequence-dividing functions.\r\n\r\n## fbind\r\n\r\n`fbind`, `fbind*`, `fbindrec`, and `fbindrec*` bind values in the\r\nfunction namespace.\r\n\r\n`fbind` and `fbindrec` are like `flet` and `labels`, respectively.\r\n\r\n    (fbind ((fn (lambda ....))) ...)\r\n    ≡ (flet ((fn ...)) ...)\r\n\r\n    (fbindrec ((fn (lambda ...))) ...)\r\n    ≡ (labels ((fn ...)) ...)\r\n\r\n`fbind*` and `fbindrec*` have no exact parallels: they bind functions\r\nin sequence, so that each can be used in the construction (not just\r\nthe definition, as with `fbindrec`) of the next.\r\n\r\n    (fbind* ((flip2 (lambda (fn)\r\n                     (lambda (x y)\r\n                       (funcall fn y x))))\r\n             (xcons (flip2 #'cons)))\r\n      (xcons 2 1))\r\n    => (1 . 2)\r\n\r\nThese are non-trivial implementations. In many cases, `fbind` can\r\nproduce code that is more efficient than using `funcall`, and even\r\neliminate the overhead of higher-order functions like `compose` and\r\n`curry`. And `fbindrec`, which builds on `fbind`, further implements\r\nthe optimizing transformation from Waddell et. al., *Fixing Letrec*.\r\n\r\n## Dividing sequences\r\n\r\nAll recent functional programming languages share a family of useful\r\nsequence-related functions with terrible names. All of them are called\r\nsomething like “split”, “divide”, or “group”, more or less at random.\r\n\r\nFor each function, we ensure:\r\n\r\n- It is efficient.\r\n- It returns like sequences for like (lists for lists, strings for\r\n  strings, &c.).\r\n- It accomodates generic sequences (`list` and `vector` are not\r\n  necessarily an exhaustive partition of `sequence`).\r\n- It has a distinctive name which does not use any of the weasel words\r\n  “split,” “divide,” or “group.”\r\n\r\nThe function that returns *runs* of like elements in a sequence is\r\ncalled `runs`:\r\n\r\n    (runs '(head tail head head tail))\r\n    => '((head) (tail) (head head) (tail))\r\n\r\nThe function that returns a sequence in *batches* of a certain size is\r\ncalled `batches`:\r\n\r\n    (batches (iota 11) 2)\r\n    => ((0 1) (2 3) (4 5) (6 7) (8 9) (10))\r\n\r\nThe function which groups the like elements of a sequence is called\r\n`assort` (because it returns a sequence *assorted by* some property).\r\n\r\n    (assort (iota 10)\r\n            :key (lambda (n) (mod n 3)))\r\n    => '((0 3 6 9) (1 4 7) (2 5 8))\r\n\r\nThe function that takes a predicate and a sequence, and returns two\r\nsequences, one of the elements for which the function returns true,\r\nand one of the elements for which it returns false, is (still) called\r\n`partition`.\r\n\r\n    (partition #'oddp (iota 10))\r\n    => (1 3 5 7 9), (0 2 4 6 8)\r\n\r\nThe generalized version of `partition`, which takes a number of\r\nfunctions and returns the items that satisfy each condition, is called\r\n`partitions`.\r\n\r\n    (partitions (list #'primep #'evenp) (iota 10))\r\n    => ((2 3 5 7) (0 4 6 8)), (1 9)\r\n\r\nItems that do not belong in any partition are returned as a second value.\r\n\r\nSerapeum simply re-exports `split-sequence`, which seems to be firmly\r\nrooted under its present name.\r\n\r\n# Function reference.\r\n\r\n## Macro Tools\r\n\r\n### `(string-gensym x)`\r\n\r\nEquivalent to (gensym (string x)).\r\n\r\nGenerally preferable to calling GENSYM with a string, because it\r\nrespects the current read table.\r\n\r\nThe alternative to writing `(mapcar (compose #'gensym #'string) ...)'\r\nin every other macro.\r\n\r\n### `(unsplice form)`\r\n\r\nIf FORM is non-nil, wrap it in a list.\r\n\r\nThis is useful with ,@ in macros, and with `mapcan`.\r\n\r\nFrom Lparallel.\r\n\r\n### `(with-thunk (var &rest args) &body body)`\r\n\r\nA macro-writing macro for the `call-with-` style.\r\n\r\nIn the `call-with-` style of writing macros, the macro is simply a\r\nsyntactic convenience that wraps its body in a thunk and a call to the\r\nfunction that does the actual work.\r\n\r\n    (defmacro with-foo (&body body)\r\n      `(call-with-foo (lambda () ,@body)))\r\n\r\nThe `call-with-` style has many advantages. Functions are easier to\r\nwrite than macros; you can change the behavior of a function without\r\nhaving to recompile all its callers; functions can be traced, appear\r\nin backtraces, etc.\r\n\r\nBut meanwhile, all those thunks are being allocated on the heap. Can\r\nwe avoid this? Yes, but at a high cost in boilerplate: the closure has\r\nto be given a name (using `flet`) so it can be declared\r\n`dynamic-extent`.\r\n\r\n    (defmacro with-foo (&body body)\r\n      (with-gensyms (thunk)\r\n        `(flet ((,thunk () ,@body))\r\n           (declare (dynamic-extent #',thunk))\r\n           (call-with-foo #',thunk))))\r\n\r\n`with-thunk` avoids the boilerplate:\r\n\r\n    (defmacro with-foo (&body body)\r\n      (with-thunk (body)\r\n        `(call-with-foo #',body)))\r\n\r\nIt is also possible to construct a \"thunk\" with arguments.\r\n\r\n    (with-thunk (body foo)\r\n      `(call-with-foo #',body))\r\n    ≡ `(flet ((,thunk (,foo)\r\n          ,@body))\r\n        (declare (dynamic-extent #',thunk))\r\n        (call-with-foo #',thunk))\r\n\r\nNeeds a better name.\r\n\r\n### `(expand-macro form &optional env)`\r\n\r\nLike `macroexpand-1`, but also expand compiler macros.\r\nFrom Swank.\r\n\r\n### `(expand-macro-recursively form &optional env)`\r\n\r\nLike `macroexpand`, but also expand compiler macros.\r\nFrom Swank.\r\n\r\n### `(parse-declarations declarations)`\r\n\r\nPick apart a list of `declare` forms.\r\n\r\nParse DECLARATIONS into an alist of (identifier . declarations).\r\nDeclarations should be a list like ((declare ...) ...), as would be\r\nreturned by `alexandria:parse-body`.\r\n\r\nDeclarations that are specific to functions are normalized to\r\nuse `(function ,identifier).\r\n\r\nType declarations are normalized to the form `(type ,type).\r\n\r\nFtype declarations are also normalized.\r\n\r\n     (parse-declarations\r\n      '((declare\r\n         (fixnum x)\r\n         (type list xs)\r\n         (ftype (-> list fixnum) frob)\r\n         (inline frob)\r\n         (dynamic-extent #'frob))))\r\n     => '((#'frob dynamic-extent inline (ftype (-> list fixnum)))\r\n          (xs (type list))\r\n          (x (type fixnum)))\r\n\r\nReturn any optimizations declared as a second value.\r\n\r\n### `(expand-declaration decl)`\r\n\r\nOpposite of `parse-declarations`.\r\n\r\nTake a (identifier . declarations) pair, as returned by\r\n`parse-declarations`, and turn it into a declaration form that can be\r\nused in Lisp code.\r\n\r\n     (locally ,(expand-declaration decl) ...)\r\n\r\nMight be used to transfer declarations made for a variable to another,\r\ntemporary variable.\r\n\r\n### `(partition-declarations xs declarations)`\r\n\r\nSplit DECLARATIONS into those that do and do not apply to XS.\r\nReturn two values, one with each set.\r\n\r\nBoth sets of declarations are returned in a form that can be spliced\r\ndirectly into Lisp code:\r\n\r\n     (locally ,@(partition-declarations vars decls) ...)\r\n\r\n## Types\r\n\r\n### `(-> function args values)`\r\n\r\nDeclaim the ftype of a function from ARGS to VALUES.\r\n\r\n     (-> mod-fixnum+ (fixnum fixnum) fixnum)\r\n     (defun mod-fixnum+ (x y) ...)\r\n\r\n## Definitions\r\n\r\n### `(def var &body (val &optional (doc nil docp)))`\r\n\r\nThe famous \"deflex\".\r\n\r\nDefine a top level (global) lexical VAR with initial value VAL,\r\nwhich is assigned unconditionally as with DEFPARAMETER. If a DOC\r\nstring is provided, it is attached to both the name |VAR| and the name\r\n*STORAGE-FOR-DEFLEX-VAR-|VAR|* as a documentation string of kind\r\n'VARIABLE. The new VAR will have lexical scope and thus may be\r\nshadowed by LET bindings without affecting its dynamic (global) value.\r\n\r\nIn implementations that support it (SBCL and CCL, at the moment) this\r\nversion creates a backing variable that is \"global\" or \"static\",\r\nso there is not just a change in semantics, but also a gain in\r\nefficiency.\r\n\r\nThe original `deflex` is due to Rob Warnock.\r\n\r\n### `(defconst symbol init &optional docstring)`\r\n\r\nDefine a constant, lexically.\r\n\r\n`defconst` defines a constant using a strategy similar to `def`, so\r\nyou don’t have to +cage+ your constants.\r\n\r\nThe name is from Emacs Lisp.\r\n\r\n### `(defsubst name params &body body)`\r\n\r\nDefine an inline function.\r\n\r\n     (defsubst fn ...)\r\n     ≡ (declaim (inline fn))\r\n       (defun fn ...)\r\n\r\nThe advantage of a separate defining form for inline functions is that\r\nyou can't forget to declaim the function inline before defining it –\r\nwithout which it may not actually end up being inlined.\r\n\r\nFrom Emacs and other ancient Lisps.\r\n\r\n### `(defalias alias &body (def &optional docstring))`\r\n\r\nDefine a value as a top-level function.\r\n\r\n     (defalias string-gensym (compose #'gensym #'string))\r\n\r\nLike (setf (fdefinition ALIAS) DEF), but with a place to put\r\ndocumentation and some niceties to placate the compiler.\r\n\r\nName from Emacs Lisp.\r\n\r\n### `(defplace name args &body (form &optional docstring))`\r\n\r\nDefine NAME and (SETF NAME) in one go.\r\n\r\nNote that the body must be a single, setf-able expression.\r\n\r\n### `(defcondition name supers &body (slots &rest options))`\r\n\r\nAlias for `define-condition`.\r\n\r\nLike (define-condition ...), but blissfully conforming to the same\r\nnomenclatural convention as every other definition form in Common\r\nLisp.\r\n\r\n## Binding\r\n\r\n### `(lret (&rest bindings) &body body)`\r\n\r\nReturn the initial value of the last binding in BINDINGS. The idea\r\nis to create something, initialize it, and then return it.\r\n\r\n`lret` may seem trivial, but it fufills the highest purpose a macro\r\ncan: it eliminates a whole class of bugs (initializing an object, but\r\nforgetting to return it).\r\n\r\nCf. `aprog1` in Anaphora.\r\n\r\n### `(lret* (&rest bindings) &body body)`\r\n\r\nCf. `lret`.\r\n\r\n### `(letrec (&rest bindings) &body body)`\r\n\r\nRecursive LET.\r\nThe idea is that functions created in BINDINGS can close over one\r\nanother, and themselves.\r\n\r\nNote that `letrec` only binds variables: it can define functions, but\r\ncan't bind them as functions. (But see `fbindrec`.)\r\n\r\n### `(letrec* (&rest bindings) &body body)`\r\n\r\nLike LETREC, but the bindings are evaluated in order.\r\nSee Waddell et al., *Fixing Letrec* for motivation.\r\n\r\nCf. `fbindrec*`.\r\n\r\n### `(mvlet* (&rest bindings) &body body)`\r\n\r\nExpand a series of nested `multiple-value-bind` forms.\r\n\r\n`mvlet*` is similar in intent to Scheme’s `let-values`, but with a\r\ndifferent and less parenthesis-intensive syntax. Each binding is a\r\nlist of\r\n\r\n    (var var*... expr)\r\n\r\nA simple example should suffice to show both the implementation and\r\nthe motivation:\r\n\r\n    (defun uptime (seconds)\r\n      (mvlet* ((minutes seconds (truncate seconds 60))\r\n               (hours minutes (truncate minutes 60))\r\n               (days hours (truncate hours 24)))\r\n        (declare ((integer 0 *) days hours minutes seconds))\r\n        (fmt \"~d day~:p, ~d hour~:p, ~d minute~:p, ~d second~:p\"\r\n             days hours minutes seconds)))\r\n\r\nNote that declarations work just like `let*`.\r\n\r\n### `(mvlet (&rest bindings) &body body)`\r\n\r\nParallel (`let`-like) version of `mvlet*`.\r\n\r\n### `(and-let* (&rest clauses) &body body)`\r\n\r\nScheme's guarded LET* (SRFI-2).\r\n\r\nEach clause should have one of the following forms:\r\n\r\n`identifier`\r\n    in which case identifier's value is tested.\r\n`(expression)`\r\n    in which case the value of expression is tested.\r\n`(identifier expression)'\r\n    in which case expression is evaluated, and, if its value is not\r\n    false, identifier is bound to that value for the remainder of the\r\n    clauses and the optional body.\r\n\r\nNote of course that the semantics are different in Common Lisp,\r\nbecause our AND short-circuits on null, not false.\r\n\r\n## Control Flow\r\n\r\n### `(eval-and-compile &body body)`\r\n\r\nEmacs's `eval-and-compile`.\r\n\r\nShorthand for\r\n        (eval-when (:compile-toplevel :load-toplevel :execute) ...)\r\n\r\n### `(no x)`\r\n\r\nAnother alias for `not` and `null`.\r\n\r\nFrom Arc.\r\n\r\n### `(nor &rest forms)`\r\n\r\nEquivalent to (not (or ...)).\r\n\r\nFrom Arc.\r\n\r\n### `(case-using pred keyform &body clauses)`\r\n\r\nISLISP's case-using.\r\n\r\n     (case-using #'eql x ...)\r\n     ≡ (case x ...).\r\n\r\nNote that, no matter the predicate, the keys are not evaluated.\r\n\r\nThis version supports both single-item clauses (x ...) and\r\nmultiple-item clauses ((x y) ...), as well as (t ...) for the default\r\nclause.\r\n\r\n### `(string-case stringform &body cases)`\r\n\r\nEfficient `case`-like macro with string keys.\r\n\r\nThis uses Paul Khuong's `string-case` macro internally.\r\n\r\n### `(string-ecase stringform &body cases)`\r\n\r\nEfficient `ecase`-like macro with string keys.\r\n\r\nCf. `string-case`.\r\n\r\n### `(econd &rest clauses)`\r\n\r\nLike `cond`, but signal an error of type `econd-failure` if no\r\nclause succeeds.\r\n\r\n### `(cond-let var &body clauses)`\r\n\r\nCross between COND and LET.\r\n\r\n     (cond-let x ((test ...)))\r\n     ≡ (let (x)\r\n         (cond ((setf x test) ...)))\r\n\r\nCf. `acond` in Anaphora.\r\n\r\n### `(econd-let symbol &rest clauses)`\r\n\r\nLike `cond-let` for `econd`.\r\n\r\n### `(cond-every &body clauses)`\r\n\r\nLike `cond`, but instead of stopping after the first clause that\r\nsucceeds, run all the clauses that succeed.\r\n\r\nReturn the value of the last successful clause.\r\n\r\nIf a clause begins with `cl:otherwise`, it runs only if no preceding\r\nform has succeeded.\r\n\r\nFrom Zetalisp.\r\n\r\n### `(case-let (var expr) &body cases)`\r\n\r\nLike (let ((VAR EXPR)) (case VAR ...))\r\n\r\n### `(ecase-let (var expr) &body cases)`\r\n\r\nLike (let ((VAR EXPR)) (ecase VAR ...))\r\n\r\n### `(comment &body body)`\r\n\r\nA macro that ignores its body and does nothing. Useful for\r\ncomments-by-example.\r\n\r\nAlso, as noted in EXTENSIONS.LISP of 1992, \"This may seem like a\r\nsilly macro, but used inside of other macros or code generation\r\nfacilities it is very useful - you can see comments in the (one-time)\r\nmacro expansion!\"\r\n\r\n### `(example &body body)`\r\n\r\nLike `comment`.\r\n\r\n### `(nix place)`\r\n\r\nSet PLACE to nil and return the old value of PLACE.\r\n\r\nThis may be more efficient than (shiftf place nil), because it only\r\nsets PLACE when it is not already null.\r\n\r\n### `(ensure place &body newval)`\r\n\r\nEssentially (or place (setf place newval)).\r\n\r\nPLACE is treated as unbound if it returns `nil`, signals\r\n`unbound-slot`, or signals `unbound-variable`.\r\n\r\nNote that ENSURE is `setf`-able, so you can do things like\r\n     (incf (ensure x 0))\r\n\r\nCf. `ensure2`.\r\n\r\n### `(ensure2 place &body newval)`\r\n\r\nLike `ensure`, but specifically for accessors that return a second\r\nvalue like `gethash`.\r\n\r\n### `(callf function place &rest args)`\r\n\r\nSet PLACE to the value of calling FUNCTION on PLACE, with ARGS.\r\n\r\n### `(callf2 function arg1 place &rest args)`\r\n\r\nLike CALLF, but with the place as the second argument.\r\n\r\n### `(~> needle &rest holes)`\r\n\r\nThreading macro from Clojure (by way of Racket).\r\n\r\nThread NEEDLE through HOLES, where each hole is either a\r\nsymbol (equivalent to `(hole needle)`) or a list (equivalent to `(hole\r\nneedle args...)`).\r\n\r\nAs an extension, an underscore in the argument list is replaced with\r\nthe needle, so you can pass the needle as an argument other than the\r\nfirst.\r\n\r\n### `(~>> needle &rest holes)`\r\n\r\nLike `~>` but, by default, thread NEEDLE as the last argument\r\ninstead of the first.\r\n\r\n### `(select keyform &body clauses)`\r\n\r\nLike `case`, but with evaluated keys.\r\n\r\nNote that, like `case`, `select` interprets a list as the first\r\nelement of a clause as a list of keys. To use a form as a key, you\r\nmust add an extra set of parentheses.\r\n\r\n     (select 2\r\n       ((+ 2 2) t))\r\n     => T\r\n\r\n     (select 4\r\n       (((+ 2 2)) t))\r\n     => T\r\n\r\nThis version of `select` is smart enough to compile itself to a `case`\r\nstatement if all its keys are constants.\r\n\r\nFrom Zetalisp.\r\n\r\n### `(selector keyform fn &body clauses)`\r\n\r\nLike `select`, but compare using FN.\r\n\r\nNote that (unlike `case-using`), FN is not evaluated.\r\n\r\nFrom Zetalisp.\r\n\r\n### `(atomic &body body)`\r\n\r\nRun BODY as an anonymous critical section.\r\n\r\nOnly one thread can run BODY at a time.\r\n\r\n## Iter\r\n\r\n### `(nlet name (&rest bindings) &body body)`\r\n\r\nWithin BODY, bind NAME as a function, somewhat like LABELS, but\r\nwith the guarantee that recursive calls to NAME will not grow the\r\nstack.\r\n\r\n`nlet` resembles Scheme’s named let, and is used for the same purpose:\r\nwriting loops using tail recursion. You could of course do this with\r\n`labels` as well, at least under some Lisp implementations, but `nlet`\r\nguarantees tail call elimination anywhere and everywhere.\r\n\r\n    (nlet rec ((i 1000000))\r\n      (if (= i 0)\r\n          0\r\n          (rec (1- i))))\r\n    => 0\r\n\r\nBeware: because of the way it is written (literally, a GOTO with\r\narguments), `nlet` is limited: self calls must be tail calls. That is,\r\nyou cannot use `nlet` for true recursion.\r\n\r\nThe name comes from `Let Over Lambda', but this is a different\r\nimplementation: the function is not bound while the initial arguments\r\nare being evaluated, and it is safe to close over the arguments.\r\n\r\n### `(collecting &body body)`\r\n\r\nWithin BODY, bind `collect` to a function of one arguments that\r\naccumulate all the arguments it has been called with in order, like\r\nthe collect clause in `loop`, finally returning the collection.\r\n\r\nTo see the collection so far, call `collect` with no arguments.\r\n\r\nNote that this version of `collecting` binds `collect` to a closure,\r\nnot a macro: you can pass the collector around or return it like any\r\nother function.\r\n\r\n### `(summing &body body)`\r\n\r\nWithin BODY, bind `sum` to a function that gathers numbers to sum.\r\n\r\nReturn the total.\r\n\r\n### `(minimizing &body body)`\r\n\r\nWithin BODY, bind `minimize` to a function that tracks its least argument.\r\n\r\nReturn the minimum.\r\n\r\n### `(maximizing &body body)`\r\n\r\nWithin BODY, bind `maximize` to a function that tracks its greatest argument.\r\n\r\nReturn the maximum.\r\n\r\n## Conditions\r\n\r\n### `(ignoring type &body body)`\r\n\r\nAn improved version of `ignore-errors`.\r\n\r\nThe behavior is the same: if an error occurs in the body, the form\r\nreturns two values, `nil` and the condition itself.\r\n\r\n`ignoring` forces you to specify the kind of error you want to ignore:\r\n\r\n    (ignoring parse-error\r\n      ...)\r\n\r\nI call it an improvement because I think `ignore-errors` is too broad:\r\nby hiding all errors it becomes itself a source of bugs.\r\n\r\nOf course you can still ignore all errors, at the cost of one extra\r\ncharacter:\r\n\r\n    (ignoring error\r\n      ...)\r\n\r\nNB `(ignoring t)` is a bad idea.\r\n\r\n## Op\r\n\r\n### `(op &body body)`\r\n\r\nGOO's simple macro for positional lambdas.\r\n\r\nAn OP is like a lambda without an argument list. Within the body of the OP\r\nform, an underscore introduces a new argument.\r\n\r\n     (reduce (op (set-intersection _ _ :test #'equal))\r\n             sets)\r\n\r\nYou can refer back to each argument by number, starting with _1.\r\n\r\n     (funcall (op (+ _ _1)) 2) => 4\r\n\r\nYou can also use positional arguments directly:\r\n\r\n     (reduce (op (funcall _2 _1)) ...)\r\n\r\nArgument lists can be sparse:\r\n\r\n     (apply (op (+ _1 _3 _5)) '(1 2 3 4 5)) => 9\r\n\r\nNote that OP with a single argument is equivalent to CONSTANTLY:\r\n\r\n     (funcall (op 1)) => 1\r\n\r\nand that OP with a single placeholder is equivalent to IDENTITY:\r\n\r\n     (funcall (op _) 1) => 1\r\n\r\nOP can also be used to define variadic functions by using _* as the\r\nplaceholder. It is not necessary to use APPLY.\r\n\r\n     (apply (op (+ _*)) '(1 2 3 4)) => 10\r\n\r\n## Fbind\r\n\r\n### `(fbind bindings &body body)`\r\n\r\nBinds values in the function namespace.\r\n\r\nThat is,\r\n     (fbind ((fn (lambda () ...))))\r\n     ≡ (flet ((fn () ...))),\r\n\r\nexcept that a bare symbol in BINDINGS is rewritten as (symbol\r\nsymbol).\r\n\r\n### `(fbind* bindings &body body)`\r\n\r\nLike `fbind`, but creates bindings sequentially.\r\n\r\n### `(fbindrec bindings &body body)`\r\n\r\nLike `fbind`, but creates recursive bindings.\r\n\r\nThe consequences of referring to one binding in the expression that\r\ngenerates another are undefined.\r\n\r\n### `(fbindrec* bindings &body body)`\r\n\r\nLike `fbindrec`, but the function defined in each binding can be\r\nused in successive bindings.\r\n\r\n## Functions\r\n\r\n### `(partial fn &rest args)`\r\n\r\nAlias for `alexandria:curry`.\r\n\r\n### `(flip f)`\r\n\r\nFlip around the arguments of a binary function.\r\n\r\nThat is, given a binary function, return another, equivalent function\r\nthat takes its two arguments in the opposite order.\r\n\r\nFrom Haskell.\r\n\r\n### `(nth-arg n)`\r\n\r\nReturn a function that returns only its NTH argument, ignoring all others.\r\n\r\nIf you've ever caught yourself trying to do something like\r\n\r\n    (mapcar #'second xs ys)\r\n\r\nthen `nth-arg` is what you need.\r\n\r\nIf `hash-table-keys` were not already defined by Alexandria, you could\r\ndefine it thus:\r\n\r\n    (defun hash-table-keys (table)\r\n      (maphash-return (nth-arg 0) table))\r\n\r\n### `(distinct &key key test)`\r\n\r\nReturn a function that echoes only values it has not seen before.\r\n\r\n    (defalias test (distinct))\r\n    (test 'foo) => foo, t\r\n    (test 'foo) => nil, nil\r\n\r\nThe second value is T when the value is distinct.\r\n\r\nTEST must be a valid test for a hash table.\r\n\r\nThis has many uses, for example:\r\n\r\n    (count-if (distinct) seq)\r\n    ≡ (length (remove-duplicates seq))\r\n\r\n### `(throttle fn wait &key synchronized)`\r\n\r\nWrap FN so it can be called no more than every WAIT seconds.\r\nIf FN was called less than WAIT seconds ago, return the values from the\r\nlast call. Otherwise, call FN normally and update the cached values.\r\n\r\nWAIT, of course, may be a fractional number of seconds.\r\n\r\nThe throttled function is not thread-safe by default; use SYNCHRONIZED\r\nto get a version with a lock.\r\n\r\n### `(juxt &rest fns)`\r\n\r\nClojure's `juxt`.\r\n\r\nReturn a function of one argument, which, in turn, returns a list\r\nwhere each element is the result of applying one of FNS to the\r\nargument.\r\n\r\nIt’s actually quite simple, but easier to demonstrate than to explain.\r\nThe classic example is to use `juxt` to implement `partition`:\r\n\r\n    (defalias partition* (juxt #'filter #'remove-if))\r\n    (partition* #'evenp '(1 2 3 4 5 6 7 8 9 10))\r\n    => '((2 4 6 8 10) (1 3 5 7 9))\r\n\r\nThe general idea is that `juxt` takes things apart.\r\n\r\n### `(dynamic-closure symbols fn)`\r\n\r\nCreate a dynamic closure.\r\n\r\nSome ancient Lisps had closures without lexical binding. Instead, you\r\ncould \"close over\" pieces of the current dynamic environment. When\r\nthe resulting closure was called, the symbols closed over would be\r\nbound to their values at the time the closure was created. These\r\nbindings would persist through subsequent invocations and could be\r\nmutated. The result was something between a closure and a\r\ncontinuation.\r\n\r\nThis particular piece of Lisp history is worth reviving, I think, if\r\nonly for use with threads. For example, to start a thread and\r\npropagate the current value of `*standard-output*`:\r\n\r\n     (bt:make-thread (dynamic-closure '(*standard-output*) (lambda ...)))\r\n     = (let ((temp *standard-output*))\r\n         (bt:make-thread\r\n          (lambda ...\r\n            (let ((*standard-output* temp))\r\n              ...))))\r\n\r\n## Lists\r\n\r\n### `(filter-map fn list &rest lists)`\r\n\r\nMap FN over LISTS like `mapcar`, but omit empty results.\r\n\r\n     (filter-map fn ...)\r\n     ≅ (remove nil (mapcar fn ...))\r\n\r\n### `(car-safe x)`\r\n\r\nThe car of X, or nil if X is not a cons.\r\n\r\nThis is different from Alexandria’s `ensure-car`, which returns the atom.\r\n\r\n    (ensure-car '(1 . 2)) => 1\r\n    (car-safe '(1 . 2)) => 1\r\n    (ensure-car 1) => 1\r\n    (car-safe 1) => nil\r\n\r\nFrom Emacs Lisp.\r\n\r\n### `(cdr-safe x)`\r\n\r\nThe cdr of X, or nil if X is not a cons.\r\nFrom Emacs Lisp.\r\n\r\n### `(append1 list item)`\r\n\r\nAppend an atom to a list.\r\n\r\n    (append1 list item)\r\n    ≡ (append list (list item))\r\n\r\n### `(in x &rest items)`\r\n\r\nIs X equal to any of ITEMS?\r\n\r\n`(in x xs...)` is always equivalent to `(member x xs :test equal)`,\r\nbut `in` can sometimes compile to more efficient code when the\r\ncandidate matches are constant.\r\n\r\nFrom Arc.\r\n\r\n### `(memq item list)`\r\n\r\nLike (member ... :test #'eq).\r\nShould only be used for symbols.\r\n\r\n### `(delq item list)`\r\n\r\nLike (delete ... :test #'eq), but only for lists.\r\n\r\nAlmost always used as (delq nil ...).\r\n\r\n### `(mapply fn &rest lists)`\r\n\r\n`mapply` is a cousin of `mapcar`.\r\n\r\nIf you think of `mapcar` as using `funcall`:\r\n\r\n    (mapcar #'- '(1 2 3))\r\n    ≡ (loop for item in '(1 2 3)\r\n             collect (funcall #'- item))\r\n\r\nThen `mapply` does the same thing, but using `apply`.\r\n\r\n    (mapply #'+ '((1 2 3) (4 5 6)))\r\n    => (6 15)\r\n\r\nIn variadic use, `mapply` acts as if `mapcar #'append` had first been\r\nused:\r\n\r\n    (mapply #'+ xs ys)\r\n    ≡ (mapply #'+ (mapcar #'append xs ys))\r\n\r\nBut the actual implementation is more efficient.\r\n\r\n### `(assocdr item alist &rest args)`\r\n\r\nLike (cdr (assoc ...))\r\n\r\n### `(assocadr item alist &rest args)`\r\n\r\nLike `assocdr` for alists of proper lists.\r\n\r\n     (assocdr 'x '((x 1))) => '(1)\r\n     (assocadr 'x '((x 1))) => 1\r\n\r\n### `(rassocar item alist &rest args)`\r\n\r\nLike (car (rassoc ...))\r\n\r\n### `(firstn n list)`\r\n\r\nThe first N elements of LIST, as a fresh list:\r\n\r\n    (firstn 4 (iota 10))\r\n    => (0 1 2 4)\r\n\r\n(I do not why this extremely useful function did not make it into\r\nCommon Lisp, unless it was deliberately left out as an exercise for\r\nMaclisp users.)\r\n\r\n### `(inconsistent-graph-constraints inconsistent-graph)`\r\n\r\nThe constraints of an `inconsistent-graph` error.\r\nCf. `toposort`.\r\n\r\n### `(toposort elts constraints &key key tie-breaker)`\r\n\r\nThe topographical sort routine from AMOP.\r\n\r\nTakes a list of elements to sort, and a list of constraints, where each\r\nconstraint is a two-element list.\r\n\r\n    (def dem-bones '((toe foot)\r\n                     (foot heel)\r\n                     (heel ankle)\r\n                     (ankle shin)\r\n                     (shin knee)\r\n                     (knee back)\r\n                     (back shoulder)\r\n                     (shoulder neck)\r\n                     (neck head)))\r\n    (toposort (shuffle (mapcar #'car dem-bones))\r\n              dem-bones)\r\n    => (TOE FOOT HEEL ANKLE SHIN KNEE BACK SHOULDER NECK)\r\n\r\nIf the graph is inconsistent, signals an error of type\r\n`inconsistent-graph`:\r\n\r\n    (toposort '(chicken egg) '((chicken egg) (egg chicken)))\r\n    => Inconsistent graph: ((CHICKEN EGG) (EGG CHICKEN))\r\n\r\n### `(powerset set)`\r\n\r\nReturn the powerset of SET.\r\nUses a non-recursive algorithm.\r\n\r\n### `(efface item list)`\r\n\r\nDestructively remove only the first occurence of ITEM in LIST.\r\n\r\nFrom Lisp 1.5.\r\n\r\n### `(pop-assoc key alist &rest args)`\r\n\r\nLike `assoc` but, if there was a match, delete it from ALIST.\r\n\r\nFrom Newlisp.\r\n\r\n### `(mapcar-into fn list)`\r\n\r\nLike (map-into list fn list).\r\n\r\nFrom PAIP.\r\n\r\n### `(nthrest n list)`\r\n\r\nAlias for `nthcdr`.\r\n\r\n### `(deltas list &optional op)`\r\n\r\nReturn the successive differences in LIST.\r\n\r\n     (deltas '(4 9 -5 1 2))\r\n     => '(4 5 -14 6 1)\r\n\r\nFrom Q.\r\n\r\n## Trees\r\n\r\n### `(walk-tree fun tree &optional tag)`\r\n\r\nCall FUN in turn over each atom and cons of TREE.\r\n\r\nFUN can skip the current subtree with (throw TAG nil).\r\n\r\n### `(map-tree fun tree &optional tag)`\r\n\r\nWalk FUN over TREE and build a tree from the results.\r\n\r\nThe new tree may share structure with the old tree.\r\n\r\n     (eq tree (map-tree #'identity tree)) => T\r\n\r\nFUN can skip the current subtree with (throw TAG SUBTREE), in which\r\ncase SUBTREE will be used as the value of the subtree.\r\n\r\n### `(leaf-walk fun tree)`\r\n\r\nCall FUN on each leaf of TREE.\r\n\r\n### `(leaf-map fn tree)`\r\n\r\nCall FN on each leaf of TREE.\r\nReturn a new tree possibly sharing structure with TREE.\r\n\r\n### `(occurs-if test tree &key key)`\r\n\r\nIs there a node (leaf or cons) in TREE that satisfies TEST?\r\n\r\n### `(prune-if test tree &key key)`\r\n\r\nRemove any atoms satisfying TEST from TREE.\r\n\r\n### `(occurs leaf tree &key key test)`\r\n\r\nIs LEAF present in TREE?\r\n\r\n### `(prune leaf tree &key key test)`\r\n\r\nRemove LEAF from TREE wherever it occurs.\r\n\r\n## Strings\r\n\r\n### `(whitespacep char)`\r\n\r\nIs CHAR whitespace?\r\n\r\nSpaces, tabs, any kind of line break, page breaks, and no-break spaces\r\nare considered whitespace.\r\n\r\n### `(trim-whitespace string)`\r\n\r\nSTRING without whitespace at ends.\r\n\r\n### `(with-string (var &optional stream) &body body)`\r\n\r\nBind VAR to the character stream designated by STREAM.\r\n\r\nSTREAM is resolved like the DESTINATION argument to `format`: it can\r\nbe any of t (for `*standard-output*`), nil (for a string stream), a\r\nstring with a fill pointer, or a stream to be used directly.\r\n\r\nWhen possible, it is a good idea for functions that return strings to\r\ntake a stream to write to, so callers can avoid consing a string just\r\nto write it to a stream. This macro makes it easy to write such\r\nfunctions.\r\n\r\n    (defun format-x (x &key stream)\r\n      (with-string (s stream)\r\n        ...))\r\n\r\n### `(collapse-whitespace string)`\r\n\r\nCollapse runs of whitespace in STRING.\r\nEach run of space, newline, and other whitespace characters is\r\nreplaced by a single space character.\r\n\r\n### `(blankp seq)`\r\n\r\nSEQ is either empty, or consists entirely of characters that\r\nsatisfy `whitespacep`.\r\n\r\n### `(concat &rest strings)`\r\n\r\nAbbreviation for (concatenate 'string ...).\r\n\r\nFrom Emacs Lisp.\r\n\r\n### `(mapconcat fun seq separator &key stream)`\r\n\r\nBuild a string by mapping FUN over SEQ.\r\nSeparate each value with SEPARATOR.\r\n\r\nEquivalent to\r\n        (reduce #'concat (intersperse SEP SEQ) :key FUN)\r\nbut more efficient.\r\n\r\nFrom Emacs Lisp.\r\n\r\n### `(join strings &optional sep)`\r\n\r\nJoin STRINGS into one string, perhaps interspersing with SEP.\r\n\r\n### `(string-upcase-initials string)`\r\n\r\nReturn STRING with the first letter of each word capitalized.\r\nThis differs from CAPITALIZE in that the other characters in each word\r\nare not changed.\r\n\r\n     (capitalize \"an ACRONYM\") -> \"An Acronym\")\r\n     (string-upcase-initials \"an ACRONYM\") -> \"An ACRONYM\")\r\n\r\nFrom Emacs Lisp (where it is simply `upcase-initials`).\r\n\r\n### `(nstring-upcase-initials string)`\r\n\r\nDestructive version of `string-upcase-initials`.\r\n\r\n### `(nstring-invert-case string)`\r\n\r\nDestructive version of `string-invert-case`.\r\n\r\n### `(string-invert-case string)`\r\n\r\nInvert the case of STRING.\r\nThis does the same thing as a case-inverting readtable.\r\n\r\n### `(words string &key start end)`\r\n\r\nSplit STRING into words.\r\n\r\nThe definition of a word is the same as that used by\r\n`string-capitalize`: a run of alphanumeric characters.\r\n\r\n    (words \"Four score and seven years\")\r\n    => (\"Four\" \"score\" \"and\" \"seven\" \"years\")\r\n\r\n    (words \"2 words\")\r\n    => (\"2\" \"words\")\r\n\r\n    (words \"two_words\")\r\n    => (\"two\" \"words\")\r\n\r\n    (words \"\\\"I'm here,\\\" Tom said presently.\")\r\n    => (\"I\" \"m\" \"here\" \"Tom\" \"said\" \"presently\")\r\n\r\nCf. `tokens`.\r\n\r\n### `(tokens string &key start end)`\r\n\r\nSeparate STRING into tokens.\r\nTokens are runs of non-whitespace characters.\r\n\r\n    (tokens \"\\\"I'm here,\\\" Tom said presently.\")\r\n    => (\"\\\"I'm\" \"here,\\\"\" \"Tom\" \"said\" \"presently.\")\r\n\r\nCf. `words`.\r\n\r\n### `(lines string)`\r\n\r\nA list of lines in STRING.\r\n\r\n### `(fmt control-string &rest args)`\r\n\r\nA cousin of `format` expressly for fast formatting of strings.\r\n\r\nLike (format nil ...), binding `*pretty-pretty*` to `nil`, which in\r\nsome Lisps means a significant increase in speed.\r\n\r\nHas a compiler macro with `formatter`.\r\n\r\n### `(downcase x)`\r\n\r\nDowncase a string or character.\r\n\r\n### `(upcase x)`\r\n\r\nUpcase a string or character.\r\n\r\n### `(capitalize x)`\r\n\r\nCapitalize a string or character.\r\n\r\n### `(escape string table &key start end stream)`\r\n\r\nWrite STRING to STREAM, escaping with TABLE.\r\n\r\nTABLE should be either a hash table, with characters for keys and\r\nstrings for values, or a function that takes a character and returns a\r\nstring.\r\n\r\n### `(ellipsize string n &key ellipsis)`\r\n\r\nIf STRING is longer than N, truncate it and append ELLIPSIS.\r\n\r\nNote that the resulting string is longer than N by the length of\r\nELLIPSIS, so the string may come out longer than it started.\r\n\r\n     (ellipsize \"abc\" 2)\r\n     => \"ab...\"\r\n\r\nFrom Arc.\r\n\r\n### `(string-prefixp s1 s2 &key start1 end1 start2 end2)`\r\n\r\nLike `string^=`, but case-insensitive.\r\n\r\n### `(string^= s1 s2 &key start1 end1 start2 end2)`\r\n\r\nIs S1 a prefix of S2?\r\n\r\n### `(string$= s1 s2 &key start1 end1 start2 end2)`\r\n\r\nIs S1 a suffix of S2?\r\n\r\n### `(string-suffixp s1 s2 &key start1 end1 start2 end2)`\r\n\r\nLike `string$=`, but case-insensitive.\r\n\r\n### `(string-containsp s1 s2 &key start1 end1 start2 end2)`\r\n\r\nLike `string*=`, but case-insensitive.\r\n\r\n### `(string*= s1 s2 &key start1 end1 start2 end2)`\r\n\r\nIs S1 a substring of S2?\r\n\r\nThis is similar, but not identical, to SEARCH.\r\n\r\n     (search nil \"foo\") => T\r\n     (search \"nil\" \"nil\") => NIL\r\n     (string*= nil \"foo\") => NIL\r\n     (string*= nil \"nil\") => T\r\n\r\n### `(string~= s1 s2 &key start1 end1 start2 end2)`\r\n\r\nDoes S1 occur in S2 as a token?\r\n\r\nThis is equivalent to\r\n     (find S1 (tokens S2) :test #'string=),\r\nbut without consing.\r\n\r\n### `(string-tokenp s1 s2 &key start1 end1 start2 end2)`\r\n\r\nLike `string~=`, but case-insensitive.\r\n\r\n### `(string-replace-all old string new &key start end stream)`\r\n\r\nDo regex-style search-and-replace for constant strings.\r\n\r\nNote that START and END only affect where the replacements are made:\r\nthe part of the string before START, and the part after END, are\r\nalways included verbatim.\r\n\r\n     (string-replace-all \"old\" \"The old old way\" \"new\"\r\n                         :start 3 :end 6)\r\n     => \"The new old way\"\r\n\r\n## Hash Tables\r\n\r\n### `(dict &rest keys-and-values)`\r\n\r\nA concise constructor for hash tables.\r\n\r\nBy default, return an 'equal hash table containing each successive\r\npair of keys and values from KEYS-AND-VALUES.\r\n\r\nIf the number of KEYS-AND-VALUES is odd, then the first argument is\r\nunderstood as the test.\r\n\r\n     (gethash \"string\" (dict \"string\" t)) => t\r\n     (gethash \"string\" (dict 'eq \"string\" t)) => nil\r\n\r\n### `(dict* dict &rest args)`\r\n\r\nMerge new bindings into DICT.\r\nRoughly equivalent to `(merge-tables DICT (dict args...))'.\r\n\r\n### `(href table &rest keys)`\r\n\r\nA concise way of doings lookups in (potentially nested) hash tables.\r\n\r\n    (href (dict :x 1) :x) => x\r\n    (href (dict :x (dict :y 2)) :x :y)  => y\r\n\r\n### `(href-default default table &rest keys)`\r\n\r\nLike `href`, with a default.\r\nAs soon as one of KEYS fails to match, DEFAULT is returned.\r\n\r\n### `(@ table key &rest keys)`\r\n\r\nA concise way of doings lookups in (potentially nested) hash tables.\r\n\r\n    (@ (dict :x 1) :x) => x\r\n    (@ (dict :x (dict :y 2)) :x :y)  => y\r\n\r\n### `(pophash key hash-table)`\r\n\r\nLookup KEY in HASH-TABLE, return its value, and remove it.\r\nFrom Zetalisp.\r\n\r\n### `(swaphash key value hash-table)`\r\n\r\nSet KEY and VALUE in HASH-TABLE, returning the old values of KEY.\r\nFrom Zetalisp.\r\n\r\n### `(maphash-return fn hash-table)`\r\n\r\nLike MAPHASH, but collect and return the values from FN.\r\nFrom Zetalisp.\r\n\r\n### `(merge-tables table &rest tables)`\r\n\r\nMerge TABLE and TABLES, working from left to right.\r\nThe resulting hash table has the same test as TABLE.\r\n\r\nClojure's `merge`.\r\n\r\n### `(flip-hash-table table &key test key)`\r\n\r\nReturn a table like TABLE, but with keys and values flipped.\r\n\r\nTEST filters which values to set. KEY defaults to `identity`.\r\n\r\n### `(set-hash-table\r\n      set\r\n      &rest\r\n      hash-table-args\r\n      &key\r\n      test\r\n      key\r\n      strict\r\n      &allow-other-keys)`\r\n\r\nReturn SET, a list considered as a set, as a hash table.\r\nThis is the equivalent of `alist-hash-table` and `plist-hash-table`\r\nfor a list that denotes a set.\r\n\r\nSTRICT determines whether to check that the list actually is a set.\r\n\r\nThe resulting table has the members of SET for its keys and `t` for\r\nevery value.\r\n\r\n### `(hash-table-set table &key strict)`\r\n\r\nReturn the set denoted by TABLE.\r\nGiven STRICT, check that each value is `t`.\r\n\r\nWithout STRICT, equivalent to `hash-table-keys`.\r\n\r\n## Files\r\n\r\n### `(write-stream-into-file\r\n      stream\r\n      pathname\r\n      &key\r\n      if-exists\r\n      if-does-not-exist)`\r\n\r\nRead STREAM and write the contents into PATHNAME.\r\n\r\nSTREAM will be closed afterwards, so wrap it with\r\n`make-concatenated-stream` if you want it left open.\r\n\r\n### `(file= file1 file2 &key buffer-size)`\r\n\r\nCompare FILE1 and FILE2 octet by octet, using buffers of\r\nBUFFER-SIZE.\r\n\r\n### `(file-size file &key element-type)`\r\n\r\nThe size of FILE.\r\n\r\n### `(delete-file-if-exists file)`\r\n\r\nDelete FILE if it exists.\r\n\r\n## Symbols\r\n\r\n### `(find-keyword string)`\r\n\r\nIf STRING has been interned as a keyword, return it.\r\n\r\nLike `make-keyword`, but preferable in most cases, because it doesn't\r\nintern a keyword -- which is usually both unnecessary and unwise.\r\n\r\n### `(bound-value s &optional default)`\r\n\r\nIf S is bound, return (values s t). Otherwise, return DEFAULT.\r\n\r\n### `(special-variable-p symbol)`\r\n\r\nIs SYMBOL a special variable?\r\n\r\n## Arrays\r\n\r\n### `(array-index-row-major array row-major-index)`\r\n\r\nThe inverse of ARRAY-ROW-MAJOR-INDEX.\r\n\r\nGiven an array and a row-major index, return a list of subscripts.\r\n\r\n     (apply #'aref (array-index-row-major i))\r\n     ≡ (array-row-major-aref i)\r\n\r\n## Queue\r\n\r\n### `(queuep x)`\r\n\r\nIs X a queue?\r\n\r\n### `(queue &rest initial-contents)`\r\n\r\nBuild a new queue with INITIAL-CONTENTS.\r\n\r\n### `(clear-queue queue)`\r\n\r\nReturn QUEUE's contents and reset it.\r\n\r\n### `(qlen queue)`\r\n\r\nThe number of items in QUEUE.\r\n\r\n### `(qlist queue)`\r\n\r\nA list of the times in QUEUE.\r\n\r\n### `(enq item queue)`\r\n\r\nInsert ITEM at end of QUEUE.\r\n\r\n### `(deq queue)`\r\n\r\nRemove item from the front of the QUEUE.\r\n\r\n### `(front queue)`\r\n\r\nThe first element in QUEUE.\r\n\r\n### `(queue-empty-p queue)`\r\n\r\nIs QUEUE empty?\r\n\r\n### `(qconc queue list)`\r\n\r\nDestructively concatenate LIST onto the end of QUEUE.\r\n\r\n## Box\r\n\r\n### `(box value)`\r\n\r\nBox a value.\r\n\r\n### `(unbox x)`\r\n\r\nThe value in the box X.\r\n\r\n## Sequences\r\n\r\n### `(nsubseq seq start &optional end)`\r\n\r\nReturn a subsequence that may share structure with SEQ.\r\n\r\nNote that `nsubseq` gets its aposematic leading `n` not because it is\r\nitself destructive, but because, unlike `subseq`, destructive\r\noperations on the subsequence returned may mutate the original.\r\n\r\n`nsubseq` also works with `setf`, with the same behavior as\r\n`replace`.\r\n\r\n### `(filter pred\r\n            seq\r\n            &rest\r\n            args\r\n            &key\r\n            count\r\n            from-end\r\n            start\r\n            end\r\n            key\r\n            &allow-other-keys)`\r\n\r\nAlmost the opposite of `remove-if-not`.\r\nThe difference is the handling of COUNT.\r\n\r\n### `(keep item\r\n          seq\r\n          &rest\r\n          args\r\n          &key\r\n          test\r\n          from-end\r\n          count\r\n          &allow-other-keys)`\r\n\r\nAlmost the opposite of `remove`.\r\nKeep only those items in SEQ that are equivalent, under TEST and KEY,\r\nto ITEM.\r\n\r\nThe difference is the handling of COUNT.\r\n\r\n### `(single seq)`\r\n\r\nIs SEQ a sequence of one element?\r\n\r\n### `(partition pred seq &key start end key)`\r\n\r\nPartition elements of SEQ into those for which PRED returns true\r\nand false.\r\n\r\nReturn two values, one with each sequence.\r\n\r\nExactly equivalent to:\r\n     (values (remove-if predicate seq) (remove-if-not predicate seq))\r\nexcept it visits each element only once.\r\n\r\nNote that `partition` is not just `assort` with an up-or-down\r\npredicate. `assort` returns its groupings in the order they occur in\r\nthe sequence; `partition` always returns the “true” elements first.\r\n\r\n    (assort '(1 2 3) :key #'evenp) => ((1 3) (2))\r\n    (partition #'evenp '(1 2 3)) => (2), (1 3)\r\n\r\n### `(partitions preds seq &key start end key)`\r\n\r\nGeneralized version of PARTITION.\r\n\r\nPREDS is a list of predicates. For each predicate, `partitions`\r\nreturns a filtered copy of SEQ. As a second value, it returns an extra\r\nsequence of the items that do not match any predicate.\r\n\r\nItems are assigned to the first predicate they match.\r\n\r\n### `(assort seq &key key test start end)`\r\n\r\nReturn SEQ assorted by KEY.\r\n\r\n     (assort (iota 10)\r\n             :key (lambda (n) (mod n 3)))\r\n     => '((0 3 6 9) (1 4 7) (2 5 8))\r\n\r\nYou can think of `assort` as being akin to `remove-duplicates`:\r\n\r\n     (mapcar #'first (assort list))\r\n     ≡ (remove-duplicates list :from-end t)\r\n\r\n### `(runs seq &key start end key test)`\r\n\r\nReturn a list of runs of similar elements in SEQ.\r\nThe arguments START, END, and KEY are as for `reduce`.\r\n\r\n    (runs '(head tail head head tail))\r\n    => '((head) (tail) (head head) (tail))\r\n\r\n### `(batches seq n &key start end)`\r\n\r\nReturn SEQ in batches of N elements.\r\n\r\n    (batches (iota 11) 2)\r\n    => ((0 1) (2 3) (4 5) (6 7) (8 9) (10))\r\n\r\n### `(safe-sort seq pred &rest args)`\r\n\r\nLike `sort`, but not destructive.\r\n\r\n### `(sortf g11779 pred &rest args)`\r\n\r\nSort a place with `sort`.\r\n\r\n### `(frequencies seq &rest hash-table-args)`\r\n\r\nReturn a hash table with the count of each unique item in SEQ.\r\n\r\nFrom Clojure.\r\n\r\n### `(nub seq &rest args &key start end key test)`\r\n\r\nRemove duplicates from SEQ, starting from the end.\r\nTEST defaults to `equal`.\r\n\r\nFrom Haskell.\r\n\r\n### `(gcp seqs &key test)`\r\n\r\nThe greatest common prefix of SEQS.\r\n\r\n### `(gcs seqs &key test)`\r\n\r\nThe greatest common suffix of SEQS.\r\n\r\n### `(length< seq n)`\r\n\r\nIs SEQ less than N elements long?\r\n\r\n### `(length> seq n)`\r\n\r\nIs SEQ more than N elements long?\r\n\r\n### `(length>= seq n)`\r\n\r\nIs SEQ at least N elements long?\r\n\r\n### `(length<= seq n)`\r\n\r\nIs SEQ no more than N elements long?\r\n\r\n### `(longer x y)`\r\n\r\nReturn the longer of X and Y.\r\n\r\nIf X and Y are of equal length, return X.\r\n\r\n### `(longest seqs)`\r\n\r\nReturn the longest seq in SEQS.\r\n\r\n### `(cut seq indices)`\r\n\r\nDivide up SEQ at INDICES.\r\n\r\n     (cut (iota 8) '(2 4 6))\r\n     => ((0 1) (2 3) (4 5) (6 7))\r\n\r\nFrom Q.\r\n\r\n### `(slice seq start &optional end)`\r\n\r\nLike `subseq`, but allows negative bounds to specify offsets.\r\nBoth START and END accept negative bounds.\r\n\r\n     (slice \"string\" -3 -1) => \"in\"\r\n\r\nSetf of `slice` is like setf of `ldb`: afterwards, the place being set\r\nholds a new sequence which is not EQ to the old.\r\n\r\n### `(ordering seq &key unordered-to-end from-end test)`\r\n\r\nGiven a sequence, return a function that, when called with `sort`,\r\nrestores the original order of the sequence.\r\n\r\nThat is, for any SEQ (without duplicates), it is always true that\r\n\r\n     (equal seq (sort (shuffle (copy-seq seq)) (ordering seq)))\r\n\r\nFROM-END controls what to do in case of duplicates. If FROM-END is\r\ntrue, the last occurrence of each item is preserved; otherwise, only\r\nthe first occurrence counts.\r\n\r\nTEST controls identity; it should be a valid test for a hash table.\r\n\r\nUNORDERED-TO-END controls where to sort items that are not present in\r\nthe original ordering. By default they are sorted first but, if\r\nUNORDERED-TO-END is true, they are sorted last. In either case, they\r\nare left in no particular order.\r\n\r\n### `(bestn n seq pred &key key)`\r\n\r\nPartial sorting.\r\nEquivalent to (firstn N (sort SEQ PRED)), but much faster, at least\r\nfor small values of N.\r\n\r\nThe name is from Arc.\r\n\r\n### `(extrema seq pred &key key start end)`\r\n\r\nLike EXTREMUM, but returns both the minimum and the maximum (as two\r\nvalues).\r\n\r\n     (extremum (iota 10) #'>) => 9\r\n     (extrema (iota 10) #'>) => 9, 0\r\n\r\n### `(vector= v1 v2 &key test start1 end1 start2 end2)`\r\n\r\nLike `string=` for any vector.\r\n\r\n### `(take n seq)`\r\n\r\nReturn the first N elements of SEQ, as a *new* sequence of the same\r\ntype as SEQ.\r\n\r\n### `(drop n seq)`\r\n\r\nReturn all but the first N elements of SEQ.\r\nThe sequence returned is a new sequence of the same type as SEQ.\r\n\r\n### `(halves seq &optional split)`\r\n\r\nReturn, as two values, the first and second halves of SEQ.\r\nSPLIT designates where to split SEQ; it defaults to half the length,\r\nbut can be specified.\r\n\r\nIf SEQ is of an odd length, the split is made using `ceiling` rather\r\nthan `truncate`. This is on the theory that, if SEQ is a\r\nsingle-element list, it should be returned unchanged.\r\n\r\n## Numbers\r\n\r\n### `(finc place &optional (delta 1))`\r\n\r\nLike `incf`, but returns the old value instead of the new.\r\n\r\nAn alternative to using -1 as the starting value of a counter, which\r\ncan prevent optimization.\r\n\r\n### `(fdec place &optional (delta 1))`\r\n\r\nLike `decf`, but returns the old value instead of the new.\r\n\r\n### `(parse-float string &key start end junk-allowed)`\r\n\r\nBased on the venerable `parse-float` from the CMU Lisp repository.\r\nOf course you could just use `parse-number`, but sometimes only a\r\nfloat will do.\r\n\r\n### `(round-to number &optional divisor)`\r\n\r\nLike `round`, but return the resulting number.\r\n\r\n     (round 15 10) => 2\r\n     (round-to 15 10) => 20\r\n\r\n### `(bits int)`\r\n\r\nReturn a bit vector of the bits in INT.\r\n\r\n### `(unbits bits)`\r\n\r\nTurn a sequence of BITS into an integer.\r\n\r\n### `(shrink n by)`\r\n\r\nDecrease N by a factor.\r\n\r\n### `(grow n by)`\r\n\r\nIncrease N by a factor.\r\n\r\n### `(shrinkf g40488 n)`\r\n\r\nShrink the value in a place by a factor.\r\n\r\n### `(growf g40510 n)`\r\n\r\nGrow the value in a place by a factor.\r\n\r\n### `(ln n)`\r\n\r\nNatural logarithm.\r\n\r\n### `(lb n)`\r\n\r\nBinary logarithm.\r\n\r\n### `(lg n)`\r\n\r\nDecimal logarithm.\r\n\r\n### `(random-in-range low high)`\r\n\r\nRandom number in the range [low,high).\r\n\r\nFrom Zetalisp.\r\n\r\n## Octets\r\n\r\n### `(octet-vector-p x)`\r\n\r\nIs X an octet vector?\r\n\r\n### `(make-octet-vector size)`\r\n\r\nMake an octet vector of SIZE elements.\r\n\r\n### `(octets n)`\r\n\r\nReturn N, an integer, as a little-endian octet vector.\r\n\r\n### `(unoctets bytes)`\r\n\r\nConcatenate BYTES into an integer in little-endian order.\r\n\r\n## Time\r\n\r\n### `(universal-to-unix time)`\r\n\r\nConvert a universal time to a Unix time.\r\n\r\n### `(unix-to-universal time)`\r\n\r\nConvert a Unix time to a universal time.\r\n\r\n### `(get-unix-time)`\r\n\r\nThe current time as a count of seconds from the Unix epoch.\r\n\r\n### `(date-leap-year-p year)`\r\n\r\nIs YEAR a leap year in the Gregorian calendar?\r\n\r\n### `(time-since time)`\r\n\r\nReturn seconds since TIME.\r\n\r\n### `(time-until time)`\r\n\r\nReturn seconds until TIME.\r\n\r\n### `(interval &key\r\n              seconds\r\n              minutes\r\n              hours\r\n              days\r\n              weeks\r\n              months\r\n              years\r\n              month-days\r\n              year-days)`\r\n\r\nA verbose but readable way of specifying intervals in seconds.\r\n\r\nIntended as a more readable alternative to idioms\r\nlike (let ((day-in-seconds #.(* 24 60 60))) ...)\r\n\r\nHas a compiler macro.\r\n\r\n### `(with-timing (&key quiet gc repeat) &body body)`\r\n\r\nA convenience wrapper around TIME.\r\n\r\nQUIET suppresses both the return value and any output to\r\n`*standard-output*`.\r\n\r\nREPEAT specifies a number of repetitions.\r\n\r\nIf GC is non-nil, perform a garbage collection before running BODY.\r\nThis can be useful with repeated trials, when you want to make sure\r\nthe running time of the *nth* run is not distorted by cleaning up\r\nafter the runs before it.\r\n\r\n## Clos\r\n\r\n### `(make class &rest initargs)`\r\n\r\nShorthand for `make-instance`.\r\nAfter Eulisp.\r\n\r\n### `(class-name-safe x)`\r\n\r\nThe class name of the class of X.\r\nIf X is a class, the name of the class itself.\r\n\r\n### `(find-class-safe x)`\r\n\r\nThe class designated by X.\r\nIf X is a class, it designates itself.\r\n\r\n## Hooks\r\n\r\n### `(add-hook name fn)`\r\n\r\nAdd FN to the value of NAME, a hook.\r\n\r\n### `(remove-hook name fn)`\r\n\r\nRemove fn from the symbol value of NAME.\r\n\r\n### `(run-hooks &rest hookvars)`\r\n\r\nRun all the hooks in all the HOOKVARS.\r\nThe variable `*hook*` is bound to each hook as it is being run.\r\n\r\n### `(run-hook-with-args hook &rest args)`\r\n\r\nApply each function in the symbol value of HOOK to ARGS.\r\n\r\n### `(run-hook-with-args-until-failure hook &rest args)`\r\n\r\nLike `run-hook-with-args`, but quit once a function returns nil.\r\n\r\n### `(run-hook-with-args-until-success hook &rest args)`\r\n\r\nLike `run-hook-with-args`, but quit once a function returns\r\nnon-nil.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}